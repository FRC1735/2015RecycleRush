// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc1735.RecycleRush2015.subsystems;

import org.usfirst.frc1735.RecycleRush2015.Robot;
import org.usfirst.frc1735.RecycleRush2015.RobotMap;
import org.usfirst.frc1735.RecycleRush2015.commands.LiftWithJoystick;

import edu.wpi.first.wpilibj.AnalogPotentiometer;
import edu.wpi.first.wpilibj.Counter;
import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.Servo;
import edu.wpi.first.wpilibj.Solenoid;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.command.PIDSubsystem;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj.CANTalon;


/**
 *
 */
public class Lifter extends PIDSubsystem {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    SpeedController lifterMotor = RobotMap.lifterLifterMotor;
    Servo ratchetServo = RobotMap.lifterRatchetServo;
    Solenoid ratchetPiston = RobotMap.lifterRatchetPiston;
    DigitalInput toteReadyIndicator = RobotMap.lifterToteReadyIndicator;
    AnalogPotentiometer liftHeightPot = RobotMap.lifterLiftHeightPot;
    DigitalInput limitHigh = RobotMap.lifterLimitHigh;
    DigitalInput limitLow = RobotMap.lifterLimitLow;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    
    // Add a possible counter to detect limit switch pulse (in case we travel PAST the limit switch)
    Counter highLimitCounter = new Counter(limitHigh);
    
    // HACK ALERT:
    // RobotBuilder doesn't support CANTalon, so manually creating it.
    CANTalon lifterMotorCAN = RobotMap.lifterLifterMotorCAN;

    // Lifter ratchet constants
    public static final double RATCHET_ENGAGED = 90; //degrees
    public static final double RATCHET_DISENGAGED = 0;
    
    // Initialize your subsystem here
    public Lifter() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=PID
        super("Lifter", 1.0, 0.0, 0.0);
        setAbsoluteTolerance(0.2);
        getPIDController().setContinuous(false);
        LiveWindow.addActuator("Lifter", "PIDSubsystem Controller", getPIDController());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=PID

        // Set the source edge counter for the limit switch counter
        highLimitCounter.setUpSourceEdge(false, true); // rising edge, falling edge.  Our switch triggers on a falling edge.
        
        // Use these to get going:
        // setSetpoint() -  Sets where the PID controller should move the system
        //                  to
        // enable() - Enables the PID controller.
        
        // Initialize the ratchet wait time variables to zero/false so that it is a known (and small) value.
        // This is needed so that if the first thing we do with the robot is go "up", then the code that waits for current time to be later than the wait time will work properly
        m_ratchetWaitTime = 0;
        m_liftWaitTime = 0;
        m_releasingRatchet = false;
        m_heightPotTimeoutCounter = 0;
        m_lastHeightPotValue = 8.5; // Assume pot was roughly at lowest position when program started.
        
    	// FOR PID subsystem use:
        // Downward rotation of the motor is faster than the lifter will fall, and we tend to get the rope all tangled up off the spooler.
    	// Thus, clamp any negative magnitudes to some smaller (tunable) max so that we avoid this issue.
        //FIXME:  Causes exception:  Robot.lifter.setOutputRange(-0.3333, 1); // Limit downward speed to 33%
        // Try this instead:
        setOutputRange(-0.3333,1); // Limit downward speed to 33%
    }
    
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
        setDefaultCommand(new LiftWithJoystick());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
    
        // Set the default command for a subsystem here.
        //setDefaultCommand(new MySpecialCommand());
    }
    
    protected double returnPIDInput() {
        // Return your input value for the PID loop
        // e.g. a sensor, like a potentiometer:
        // yourPot.getAverageVoltage() / kYourMaxVoltage;

        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SOURCE
        return liftHeightPot.get();

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SOURCE
    }
    
    protected void usePIDOutput(double output) {
        // Use output to drive your system, like a motor
        // e.g. yourMotor.set(output);

        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=OUTPUT
        lifterMotor.pidWrite(output);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=OUTPUT
        // HACK to allow use of CANTalon.  Above motor is not utilized.
        // PID debug, step one:  physically disable the pawl and directly control the motor until we get a basic PID tuning
        // TODO:  Comment this line out when we proceed to step two of the PID debug.
        //lifterMotorCAN.pidWrite(output);
        
        // Step two... we can't just directly move to the setpoint because of the ratchet.
        // So, use the a wrapper function that the joystick manual override can also (eventually) use.
        // for now, keep the functions separate so that we dont screw up the joystick control until we have the PID system humming along!
        //lifterMove(output, System.currentTimeMillis()*1000); // Send current time in seconds to match Command time granularity
        
    }
    
    // ---------------------------------
    // User-defined functions start here
    // ---------------------------------
   
     public void ratchetDisengage() {
    	 // RobotMap.lifterRatchetServo.setAngle(RATCHET_DISENGAGED);    	
    	 // Post-Reading, we switched the ratchet mechanism and replaced the servo with a pneumatic piston
    	 RobotMap.lifterRatchetPiston.set(true);
    }

    public void ratchetEngage() {
    	// RobotMap.lifterRatchetServo.setAngle(RATCHET_ENGAGED);    	
	   	 // Post-Reading, we switched the ratchet mechanism and replaced the servo with a pneumatic piston
	   	 RobotMap.lifterRatchetPiston.set(false);
    }
    
   // Wrapper PID function for handling ratchet plus lifter.   Called by Commands.
    public void lifterMove(double setpoint, double currentTime) {
	    // Because there is a ratchet interlock, we need to determine if the ratchet needs to be disengaged before invoking the PID controller!
        // Handle the ratchet pawl
    	// If the current encoder value is BELOW (or equal to) the setpoint, engage the ratchet.
	    // If the current encoder value is ABOVE the setpoint, we have to lower the lift and should DISENGAGE the ratchet.
    	boolean goingUp = (Robot.lifter.getPosition() < setpoint),
    			stoppedOrGoingUp = (Robot.lifter.getPosition() <= setpoint);
	    if (stoppedOrGoingUp) {
	    	ratchetEngage();
		}
		else {
			// Find out if the ratchet is currently engaged:
			if (!m_releasingRatchet && (RobotMap.lifterRatchetServo.getAngle() >10)) { // engaged is 90.  Use >10 rather than >0 just in case the servo didn't truly reach zero for some reason.
				//Then we are requesting a state change to the ratchet.
				// We need to goose the motor up a little bit in order to get the ratchet disengaged from the pawl,
				// as gravity could be forcing the ratchet down against it and rendering it impossible to lift the pawl!
				// Make a guess that 40% up for the duration we wait for the servo will be sufficient:
				   // If we are right up against the limit switch or hard limit... this may not work,
				   // or may jam us completely since it ignores the limit switch and could travel up to the Point of No Return.
				   // Problem is, if we ran up to the high limit already, we can only go down, so we have to rise up a little bit even if the limit switch were activated.
				   // thus, we set the lifter magnitude to just barely rise and take the load off the pawl, but **HOPEFULLY** not enough to completely jam us.
				   // #FINGERSCROSSED
				m_releasingRatchet = true;
				ratchetDisengage();
				//Set a 40ms timer to let server get out of the way before we engage the motor downwards.
				m_liftWaitTime    = currentTime + 0.2;
				m_ratchetWaitTime = currentTime + 0.25;// With a 50ms PID polling loop, this should put us one loop out.
			}
	    }
        
        if (m_releasingRatchet && (currentTime <= m_liftWaitTime)) {
        	// Here we need to run the motor up to get the backpressure off the pawl
        	//lifterMotorCAN.set(1.0); 
        }
 
        // Wait a moment for the ratchet to get out of the way.
        // Get the current count, and continue only if we are far enough beyond it.
        // Note:  for going up, m_ratchetWaitTime will be either the constructor-time init value (0) or the last time we lowered... both of which will be less than the current time.
        if (currentTime >= m_ratchetWaitTime)
        {	
	        
        	// Clear the flag.  we're done with waiting.
        	m_releasingRatchet = false;
	        // finally, move the lifter directly.  Motor controller and joystick both work on -1..1 value range.
	        // We need limit switches to protect top and bottom lifter movement!
	        // Only move the motor if the requested direction is not in the same direction as a pressed limit switch.
	       
	        if (!((goingUp && reachedHighLimit()) ||
	        	  (!stoppedOrGoingUp && reachedLowLimit()))) {
	        	// Here we are NOT asking to move higher, but the high limit is set... or lower, but the low limit is set... 
	        	// So, we can move the motor.  Clamping of downward motion handled in the lifter's constructor.
	    	    //Robot.lifter.setSetpoint(setpoint);
	    	    //Robot.lifter.enable();
	        }
	        // Otherwise, we have hit a limit switch and are requesting to go even further.
	        // Ignore the request and just return.
        } // If not, then the ratchet may not be out of the way and we can't move the motor yet.
   	
    }
    
    public void liftWithJoystick(Joystick lifterJoy, double currentTime) {
    	//if (Robot.oi.getAccessoryJoystick().getTrigger()) { return;) //
        // Collect the Joystick info.
        // We need to filter out very small joystick values and clamp them to zero
        // so that a slightly off-center joystick doesn't send signals to the motor.
    	// Joystick is reversed direction (up is negative)
        double joy = lifterJoy.getY();
        
        //Apply Filter
        if (Math.abs(joy) < Robot.m_joystickFilter) {joy = 0;}
       
        // We don't use a PID controller at this point (As we don't have a good feedback mechanism).
        // Even if using a PID, you could use the joystick to bump the setpoint up and down.  :-)
        //
        // Instead, explicitly make sure the PID controller is disabled, and then access the motor controller directly.
        // Use limit switches to prevent us from (literally) going off the rails.
        Robot.lifter.disable(); // Make sure the PID controller is still disabled (in case something enabled it)

        double magnitude = joy; // We want joystick "up" (negative joy values) to be lifter down, keep polarity numbers for the remainder of the calculations....
        
        liftWithLimits(magnitude, currentTime);
    }
    
    // NON-PID function for controlling the lifter
    public void liftWithLimits(double magnitude, double currentTime) {
    	double currentHeight = liftHeightPot.get(); // Used for downward timeout counter
    	
        // Handle the ratchet pawl
        // if we are going up (or stopping!), engage the ratchet.
        // If we are going down, disengage the ratchet        // Negative Y values are joystick-forward.  Define that as "down".
        if (magnitude >= 0) {
    	//if (Math.abs(magnitude) < 0.1 ) {
        	//if (magnitude > 0) {System.out.println("in liftWithLimits, magnitude >0");}
	    	ratchetEngage();
	    	m_heightPotTimeoutCounter = 0; // reset the counter that determines if we stalled going down
    		SmartDashboard.putBoolean("Down Stall", false);
        }
		else {
			// Find out if the ratchet is currently engaged:
			// Post-Reading we swapped the servo for a piston...
			//if (!m_releasingRatchet && (RobotMap.lifterRatchetServo.getAngle() > 10)) { // engaged is 90.  Use >10 rather than >0 just in case the servo didn't truly reach zero for some reason.
			if (!m_releasingRatchet && (!RobotMap.lifterRatchetPiston.get())) { // engaged is 'false' (piston active fights the spring and releases the pawl)
				//Then we are requesting a state change to the ratchet.
				// We need to goose the motor up a little bit in order to get the ratchet disengaged from the pawl,
				// as gravity could be forcing the ratchet down against it and rendering it impossible to lift the pawl!
				// Make a guess that 40% up will be sufficient:
				   // If we are right up against the limit switch or hard limit... this may not work,
				   // or may jam us completely since it ignores the limit switch and could travel up to the Point of No Return.
				   // Problem is, if we ran up to the high limit already, we can only go down, so we have to rise up a little bit even if the limit switch were activated.
				   // thus, we set the lifter magnitude to just barely rise and take the load off the pawl, but **HOPEFULLY** not enough to completely jam us.
				   // #FINGERSCROSSED
				m_releasingRatchet = true;
	        	ratchetDisengage();
				//Set a 40ms timer to let server get out of the way before we engage the motor downwards.
				m_liftWaitTime    = currentTime + 0.2;
				//m_ratchetWaitTime = currentTime + 0.25;// With a 20ms polling loop, this should put us two loops out.  One was not enough.
				m_ratchetWaitTime = currentTime + 0.1;// With a 20ms polling loop, this should put us five loops out.  Plenty of time for a fast piston...
			}
	    }
/* No longer needed with piston
        if (m_releasingRatchet && currentTime <= m_liftWaitTime) {
        	// Here we need to run the motor up to get the backpressure off the pawl
			//lifterMotorCAN.set(1.0); // Motor magnitude is nonlinear, so 40% of full value is actually much less than that power-wise.        	
        }
*/        
        // Wait a moment for the ratchet pawl to get out of the way.
        // Get the current count, and continue only if we are far enough beyond it.
        // Note:  for going up, m_ratchetWaitTime will be either the constructor-time init value (0) or the last time we lowered... both of which will be less than the current time.
        if (currentTime >= m_ratchetWaitTime)
        {
        	System.out.println("we are past ratchetWaitTime");
        	// Clear the flag.  we're done with waiting.
        	m_releasingRatchet = false;
	        // finally, move the lifter directly.  Motor controller and joystick both work on -1..1 value range.
	        // We need limit switches to protect top and bottom lifter movement!
	        // Only move the motor if the requested direction is not in the same direction as a pressed limit switch.
	       
	        if (!(((magnitude >= 0) && reachedHighLimit()) ||
	        	  ((magnitude < 0) && reachedLowLimit()))) {
	        	// Here we are NOT asking to move higher, but the high limit is set... or lower, but the low limit is set... 
	        	// So, we can move the motor
	        	// Downward rotation of the motor is faster than the lifter will fall, and we tend to get the rope all tangled up off the spooler.
	        	// Thus, clamp any negative magnitudes to some smaller (tunable) max so that we avoid this issue.
	        	if (magnitude < -0.3333) { magnitude = -0.3333; }// Clamp downward motion to a max of this value
	        	
	        	// Next problem:  If the lifter arm hits an obstacle (like, say, a misaligned tote) the motor will continue to 
	        	// unspool and the rope will STILL unspool and tangle.
	        	// So, check whether the tape pot has moved since the last N polling intervals.  If it hasn't, then
	        	// we should stop the motor from going further down.
	        	if (magnitude < 0) {
	        		// Allow for some noise in the system.  Say, +/- 0.1...
	        		double delta_low = m_lastHeightPotValue - 0.01 ; // relative to pot
	        		double delta_high = m_lastHeightPotValue + 0.01;
        			if (Robot.m_debugOn) {System.out.println("previous height = " + m_lastHeightPotValue + ", Current height = " + currentHeight + ", delta_low= " + delta_low + ", delta_high = " + delta_high);}
	        		
	        		if ((currentHeight > delta_low) && (currentHeight < delta_high)) {
	        			// e.g. delta_low = 6.9
	        			//      current = 7.0
	        			//      delta_high = 7.1
	        			// if > low and < high, we are within the noise margin of not having moved since the last polling interval.
	        			m_heightPotTimeoutCounter++;
	        			//currentHeight.if (Robot.m_debugOn) {System.out.println("Incrementing timeout.  New value = " + m_heightPotTimeoutCounter);}
	        		}
	        	} // if going down
	        	
	        	if (m_heightPotTimeoutCounter <= 3) {
	        		lifterMotorCAN.set(magnitude);
	        		if (Robot.m_debugOn && (magnitude != 0)) {System.out.println("at time " + currentTime + " engaging lifter with magnitude = " + magnitude);}
	        		// Alternate counter-based limit switch would need to reset the counter if moving in a direction away from the limit switch, e.g., 
	        		//if (magnitude < 0) {highLimitCounter.reset()};
	        	}
	        	else {
	        		// otherwise we were moving down and the tape pot wasn't keeping pace.  Don't move the motor.
	            	lifterMotorCAN.set(0);

	            	// Also, put a big visual indicator on the screen to indicate the condition!
	        		SmartDashboard.putBoolean("Down Stall", true);
	        		//System.out.println("at time " + currentTime + " Down Timeout reached!  Count = " + m_heightPotTimeoutCounter);
	        	}
	        } // limitswitch check
	        // Otherwise, we have hit a limit switch and are requesting to go even further.
	        // Ignore the request and just return.
        } // Ratchet wait time
		m_lastHeightPotValue = currentHeight; // save for next iteration
    }
    
    public boolean reachedHighLimit() {
    	// Digital IO reads a '1'/true when nothing is connected.
    	// If the switch gets ripped out, we want to continue operations, so we want "ok to move" to be ==1
    	// Therefore 'hit limit' should be ==0 (meaning return the opposite of what we read)
    	// Assumes switch wiring is momentary contact = grounded
    	return (!limitHigh.get());
    	// Alternate counter-based implementation:
    	///return (highLimitCounter.get() > 0);
    }

    public boolean reachedLowLimit() {
    	// Digital IO reads a '1'/true when nothing is connected.
    	// If the switch gets ripped out, we want to continue operations, so we want "ok to move" to be ==1
    	// Therefore 'hit limit' should be ==0 (meaning return the opposite of what we read)
    	// Assumes switch wiring is momentary contact = grounded
    	return (!limitLow.get());
    }
    
    public void stop() {
    	disable();
    	lifterMotorCAN.set(0);
    }
    
    public double calculateMagnitudeDirection(double setpoint) {
    	// Based on current position and desired setpoint, return the Direction/Magnitude.
    	// Do this in a general function for maintainability.
    	
    	// Query the Tape Pot.  Rough values:
    	// 9 is lowest height, 3 is highest.
    	double currentPosition = liftHeightPot.get();
    	
    	if (currentPosition >= setpoint) {
    		// Pot is wired for high numbers = low elevator, low numbers = high elevator.
    		//Therefore a currentPosition value larger than the setpoint means we are below it.  We need to go up.
    		return 1.0; // For now, assume "up" is full strength to combat large stacks.
    	}
    	else {
    		// Else, we go down
    		return -0.3333;	 // For now, assume "Down" is clamped to 1/3 speed so that the motor doesn't spin faster than gravity pulls the load down.
    	}
    }
    
    public boolean lifterTargetReached(double setpoint, double currentPosition, double magnitudeDirection) {
		// Pot is wired for high numbers = low elevator, low numbers = high elevator.
		//Therefore a currentPosition value larger than the setpoint means we are below it.
		return (((magnitudeDirection >= 0) && currentPosition <= setpoint) || // if going up and have exceeded setpoint (smaller means above), or
				((magnitudeDirection < 0 ) && currentPosition >= setpoint));  // if going down and have exceeded setpoint (bigger value means below)
    }

    public void clearTimeouts() {
    	m_liftWaitTime = 0;
    	m_ratchetWaitTime = 0;
    	m_releasingRatchet = false;
    }
// Storage for the end time of the ratchet delay wait
    double m_liftWaitTime;
    double m_ratchetWaitTime;
    boolean m_releasingRatchet;
    double m_heightPotTimeoutCounter;
    double m_lastHeightPotValue;
    
}
