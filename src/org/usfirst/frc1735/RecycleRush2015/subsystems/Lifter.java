// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc1735.RecycleRush2015.subsystems;

import org.usfirst.frc1735.RecycleRush2015.Robot;
import org.usfirst.frc1735.RecycleRush2015.RobotMap;
import org.usfirst.frc1735.RecycleRush2015.commands.LiftWithJoystick;

import edu.wpi.first.wpilibj.AnalogPotentiometer;
import edu.wpi.first.wpilibj.Counter;
import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.Servo;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.command.PIDSubsystem;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.CANTalon;


/**
 *
 */
public class Lifter extends PIDSubsystem {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    SpeedController lifterMotor = RobotMap.lifterLifterMotor;
    Servo ratchetServo = RobotMap.lifterRatchetServo;
    Servo fingerServoLeft = RobotMap.lifterFingerServoLeft;
    Servo fingerServoRight = RobotMap.lifterFingerServoRight;
    DigitalInput toteReadyIndicator = RobotMap.lifterToteReadyIndicator;
    Encoder liftHeightEncoder = RobotMap.lifterLiftHeightEncoder;
    AnalogPotentiometer liftHeightPot = RobotMap.lifterLiftHeightPot;
    DigitalInput limitHigh = RobotMap.lifterLimitHigh;
    DigitalInput limitLow = RobotMap.lifterLimitLow;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    
    // Add a possible counter to detect limit switch pulse (in case we travel PAST the limit switch)
    Counter highLimitCounter = new Counter(limitHigh);
    
    // HACK ALERT:
    // RobotBuilder doesn't support CANTalon, so manually creating it.
    CANTalon lifterMotorCAN = RobotMap.lifterLifterMotorCAN;

    // Lifter finger constants
    public static final double FINGER_ENGAGED = 30, // degrees
    		FINGER_DISENGAGED = 5; // Degrees
    
    // Lifter ratchet constants
    public static final double RATCHET_ENGAGED = 90; //degrees
    public static final double RATCHET_DISENGAGED = 0;
    
    // Initialize your subsystem here
    public Lifter() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=PID
        super("Lifter", 1.0, 0.0, 0.0);
        setAbsoluteTolerance(0.2);
        getPIDController().setContinuous(false);
        LiveWindow.addActuator("Lifter", "PIDSubsystem Controller", getPIDController());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=PID

        // Set the source edge counter for the limit switch counter
        highLimitCounter.setUpSourceEdge(false, true); // rising edge, falling edge.  Our switch triggers on a falling edge.
        
        // Use these to get going:
        // setSetpoint() -  Sets where the PID controller should move the system
        //                  to
        // enable() - Enables the PID controller.
        
        // Initialize the ratchet wait time to zero so that it is a known (and small) value.
        // This is needed so that if the first thing we do with the robot is go "up", then the code that waits for current time to be later than the wait time will work properly
        m_ratchetWaitTime = 0;
    }
    
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
        setDefaultCommand(new LiftWithJoystick());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
    
        // Set the default command for a subsystem here.
        //setDefaultCommand(new MySpecialCommand());
    }
    
    protected double returnPIDInput() {
        // Return your input value for the PID loop
        // e.g. a sensor, like a potentiometer:
        // yourPot.getAverageVoltage() / kYourMaxVoltage;

        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SOURCE
        return liftHeightPot.get();

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SOURCE
    }
    
    protected void usePIDOutput(double output) {
        // Use output to drive your system, like a motor
        // e.g. yourMotor.set(output);

        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=OUTPUT
        lifterMotor.pidWrite(output);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=OUTPUT
        // HACK to allow use of CANTalon.  Above motor is not utilized.
        // PID debug, step one:  physically disable the pawl and directly control the motor until we get a basic PID tuning
        // TODO:  Comment this line out when we proceed to step two of the PID debug.
        lifterMotorCAN.pidWrite(output);
        
        // Step two... we can't just directly move to the setpoint because of the ratchet.
        // So, use the a wrapper function that the joystick manual override can also (eventually) use.
        // for now, keep the functions separate so that we dont screw up the joystick control until we have the PID system humming along!
        //lifterMove(output, System.currentTimeMillis()*1000); // Send current time in seconds to match Command time granularity
        
    }
    
    // ---------------------------------
    // User-defined functions start here
    // ---------------------------------
   
     public void ratchetDisengage() {
    	RobotMap.lifterRatchetServo.setAngle(RATCHET_DISENGAGED);    	
    }

    public void ratchetEngage() {
    	RobotMap.lifterRatchetServo.setAngle(RATCHET_ENGAGED);    	
    }
    
   // Wrapper function for handling ratchet plus lifter.   Called by Commands.
    public void lifterMove(double setpoint, double currentTime) {
	    // Because there is a ratchet interlock, we need to determine if the ratchet needs to be disengaged before invoking the PID controller!
        // Handle the ratchet pawl
    	// If the current encoder value is BELOW (ore equal to) the setpoint, engage the ratchet.
	    // If the current encoder value is ABOVE the setpoint, we have to lower the lift and should DISENGAGE the ratchet.
    	boolean goingUp = (Robot.lifter.getPosition() < setpoint),
    			stoppedOrGoingUp = (Robot.lifter.getPosition() <= setpoint);
	    if (stoppedOrGoingUp) {
	    	ratchetEngage();
		}
		else {
			// Find out if the ratchet is currently engaged:
			if (RobotMap.lifterRatchetServo.getAngle() >2) { // engaged is 90.  Use >2 rather than >0 just in case the servo didn't truly reach zero for some reason.
				//Then we are requesting a state change to the ratchet.
				// We need to goose the motor up a little bit in order to get the ratchet disengaged from the pawl,
				// as gravity could be forcing the ratchet down against it and rendering it impossible to lift the pawl!
				// Make a guess that 40% up for the duration we wait for the servo will be sufficient:
				   // If we are right up against the limit switch or hard limit... this may not work,
				   // or may jam us completely since it ignores the limit switch and could travel up to the Point of No Return.
				   // Problem is, if we ran up to the high limit already, we can only go down, so we have to rise up a little bit even if the limit switch were activated.
				   // thus, we set the lifter magnitude to just barely rise and take the load off the pawl, but **HOPEFULLY** not enough to completely jam us.
				   // #FINGERSCROSSED
				
				lifterMotorCAN.set(0.40); // Motor magnitude is nonlinear, so 40% of full value is actually much less than that power-wise.
				//Set a 40ms timer to let server get out of the way before we engage the motor downwards.
				m_ratchetWaitTime = currentTime + 0.4;// With a 50ms PID polling loop, this should put us one loop out.
			}
			ratchetDisengage();
	    }
        
        // Wait a moment for the ratchet to get out of the way.
        // Get the current count, and continue only if we are far enough beyond it.
        // Note:  for going up, m_ratchetWaitTime will be either the constructor-time init value (0) or the last time we lowered... both of which will be less than the current time.
        if (currentTime > m_ratchetWaitTime)
        {	
	        
	        // finally, move the lifter directly.  Motor controller and joystick both work on -1..1 value range.
	        // We need limit switches to protect top and bottom lifter movement!
	        // Only move the motor if the requested direction is not in the same direction as a pressed limit switch.
	       
	        if (!((goingUp && reachedHighLimit()) ||
	        	  (!stoppedOrGoingUp && reachedLowLimit()))) {
	        	// Here we are NOT asking to move higher, but the high limit is set... or lower, but the low limit is set... 
	        	// So, we can move the motor
	        	// Downward rotation of the motor is faster than the lifter will fall, and we tend to get the rope all tangled up off the spooler.
	        	// Thus, clamp any negative magnitudes to some smaller (tunable) max so that we avoid this issue.
	        	// FIXME:  Uncomment this once lifter down-springs are installed!
	        	//if (magnitude < -0.3333) { magnitude = -0.3333; }// Clamp downward motion to a max of this value
	        	// Now we can move the lifter into position without damaging anything...
	    	    Robot.lifter.setSetpoint(setpoint);
	    	    Robot.lifter.enable();
	        }
	        // Otherwise, we have hit a limit switch and are requesting to go even further.
	        // Ignore the request and just return.
        } // If not, then the ratchet may not be out of the way and we can't move the motor yet.
   	
    }
    
    public void fingerEngage() {
    	fingerMove(FINGER_ENGAGED);
    }
    
    public void fingerDisengage() {
    	fingerMove(FINGER_DISENGAGED);
    }
 
    // Disengage fingers on the lifter to allow a stack to be depositied
    public void fingerMove(double angle) {
    	RobotMap.lifterFingerServoLeft.setAngle(angle);
    	RobotMap.lifterFingerServoRight.setAngle(angle);
    	
    }
    public void liftWithJoystick(Joystick lifterJoy, double currentTime) {
    	//if (Robot.oi.getAccessoryJoystick().getTrigger()) { return;) //
        // Collect the Joystick info.
        // We need to filter out very small joystick values and clamp them to zero
        // so that a slightly off-center joystick doesn't send signals to the motor.
    	// Joystick is reversed direction (up is negative)
        double joy = lifterJoy.getY();
        
        //Apply Filter
        if (Math.abs(joy) < Robot.m_joystickFilter) {joy = 0;}
       
        // We don't use a PID controller at this point (As we don't have a good feedback mechanism).
        // Even if using a PID, you could use the joystick to bump the setpoint up and down.  :-)
        //
        // Instead, explicitly make sure the PID controller is disabled, and then access the motor controller directly.
        // Use limit switches to prevent us from (literally) going off the rails.
        Robot.lifter.disable(); // Make sure the PID controller is still disabled (in case something enabled it)

        double magnitude = -joy; // We want joystick "up" to be positive numbers for the remainder of the calculations....

        // Handle the ratchet pawl
        // if we are going up (or stopping!), engage the ratchet.
        // If we are going down, disengage the ratchet        // Negative Y values are joystick-forward.  Define that as "up".
        if (magnitude >= 0) {
	    	ratchetEngage();
		}
		else {
			// Find out if the ratchet is currently engaged:
			if (RobotMap.lifterRatchetServo.getAngle() >2) { // engaged is 90.  Use >2 rather than >0 just in case the servo didn't truly reach zero for some reason.
				//Then we are requesting a state change to the ratchet.
				// We need to goose the motor up a little bit in order to get the ratchet disengaged from the pawl,
				// as gravity could be forcing the ratchet down against it and rendering it impossible to lift the pawl!
				// Make a guess that 40% up for the duration we wait for the servo will be sufficient:
				   // If we are right up against the limit switch or hard limit... this may not work,
				   // or may jam us completely since it ignores the limit switch and could travel up to the Point of No Return.
				   // Problem is, if we ran up to the high limit already, we can only go down, so we have to rise up a little bit even if the limit switch were activated.
				   // thus, we set the lifter magnitude to just barely rise and take the load off the pawl, but **HOPEFULLY** not enough to completely jam us.
				   // #FINGERSCROSSED
				
				lifterMotorCAN.set(0.40); // Motor magnitude is nonlinear, so 40% of full value is actually much less than that power-wise.
				//Set a 40ms timer to let server get out of the way before we engage the motor downwards.
				m_ratchetWaitTime = currentTime + 0.4;// With a 20ms polling loop, this should put us two loops out.  One was not enough.
			}
			ratchetDisengage();
	    }
        
        // Wait a moment for the ratchet to get out of the way.
        // Get the current count, and continue only if we are far enough beyond it.
        // Note:  for going up, m_ratchetWaitTime will be either the constructor-time init value (0) or the last time we lowered... both of which will be less than the current time.
        if (currentTime > m_ratchetWaitTime)
        {	
	        
	        // finally, move the lifter directly.  Motor controller and joystick both work on -1..1 value range.
	        // We need limit switches to protect top and bottom lifter movement!
	        // Only move the motor if the requested direction is not in the same direction as a pressed limit switch.
	       
	        if (!(((magnitude > 0) && reachedHighLimit()) ||
	        	  ((magnitude < 0) && reachedLowLimit()))) {
	        	// Here we are NOT asking to move higher, but the high limit is set... or lower, but the low limit is set... 
	        	// So, we can move the motor
	        	// Downward rotation of the motor is faster than the lifter will fall, and we tend to get the rope all tangled up off the spooler.
	        	// Thus, clamp any negative magnitudes to some smaller (tunable) max so that we avoid this issue.
	        	// FIXME:  Uncomment this once lifter down-springs are installed!
	        	//if (magnitude < -0.3333) { magnitude = -0.3333; }// Clamp downward motion to a max of this value
	        	lifterMotorCAN.set(magnitude);
	        	// Alternate counter-based limit switch would need to reset the counter if moving in a direction away from the limit switch, e.g., 
	        	//if (magnitude < 0) {highLimitCounter.reset()};
	        }
	        // Otherwise, we have hit a limit switch and are requesting to go even further.
	        // Ignore the request and just return.
        } // If not, then the ratchet may not be out of the way and we can't move the motor yet.
    }
    
    public boolean reachedHighLimit() {
    	// Digital IO reads a '1'/true when nothing is connected.
    	// If the switch gets ripped out, we want to continue operations, so we want "ok to move" to be ==1
    	// Therefore 'hit limit' should be ==0 (meaning return the opposite of what we read)
    	// Assumes switch wiring is momentary contact = grounded
    	return (!limitHigh.get());
    	// Alternate counter-based implementation:
    	///return (highLimitCounter.get() > 0);
    }

    public boolean reachedLowLimit() {
    	// Digital IO reads a '1'/true when nothing is connected.
    	// If the switch gets ripped out, we want to continue operations, so we want "ok to move" to be ==1
    	// Therefore 'hit limit' should be ==0 (meaning return the opposite of what we read)
    	// Assumes switch wiring is momentary contact = grounded
    	return (!limitLow.get());
    }

// Storage for the end time of the ratchet delay wait
    double m_ratchetWaitTime;
    
}
